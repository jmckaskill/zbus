package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

type settings struct {
	tmpdir string

	platforms map[string]bool

	exeExtension string
	libExtension string
	objExtension string

	compiler          string
	compileFlags      string
	compileFlagsParts []string
	linker            string
	linkFlags         string
	archiver          string
	archiveFlags      string
	depsType          string

	enableAutostart bool
	enableDebug     bool

	haveProcGroups    bool
	haveReadyFifo     bool
	haveAtomicCloexec bool
	haveUnixGroups    bool
	haveWindowsSID    bool
	haveMemrchr       bool
	haveAlignedAlloc  bool
	haveGetEntropy    bool
	haveWcsdup        bool
	haveScmRights     bool
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func (s *settings) compile(str string) error {
	f, err := os.CreateTemp(s.tmpdir, "test*.c")
	fn := f.Name()
	must(err)
	f.WriteString(str)
	f.Close()

	var args []string
	switch s.depsType {
	case "gcc":
		args = s.gccCCFlags(fn + ".o")
	case "msvc":
		args = append(s.msvcCFlags(fn+".obj"), "/Fe:"+fn+".exe")
	}
	args = append(args, fn)
	log.Printf("CC %q %v %v", str, s.compiler, args)
	cmd := exec.Command(s.compiler, args...)
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	log.Printf("CC returned %v", err)
	return err
}

func (s *settings) testCompile(str string) bool {
	return s.compile(str) == nil
}

func getFiles(dir, ext string) []string {
	entries, err := os.ReadDir(dir)
	must(err)
	ret := []string{}
	for _, e := range entries {
		if !e.IsDir() && filepath.Ext(e.Name()) == ".c" {
			ret = append(ret, filepath.Join(dir, e.Name()))
		}
	}
	return ret
}

func writeBoolDefine(w io.Writer, name string, val bool) {
	v := 0
	if val {
		v = 1
	}
	fmt.Fprintf(w, "#define %s %d\n", name, v)
}

func (s *settings) writeConfigHeader() {
	prev, _ := os.ReadFile("config.h")

	buf := bytes.Buffer{}
	fmt.Fprintf(&buf, "#pragma once\n")
	fmt.Fprintf(&buf, "// auto generated by configure.go\n")
	writeBoolDefine(&buf, "HAVE_PROC_GROUPS", s.haveProcGroups)
	writeBoolDefine(&buf, "HAVE_READY_FIFO", s.haveReadyFifo)
	writeBoolDefine(&buf, "HAVE_ATOMIC_CLOEXEC", s.haveAtomicCloexec)
	writeBoolDefine(&buf, "HAVE_UNIX_GROUPS", s.haveUnixGroups)
	writeBoolDefine(&buf, "HAVE_WINDOWS_SID", s.haveWindowsSID)
	writeBoolDefine(&buf, "HAVE_MEMRCHR", s.haveMemrchr)
	writeBoolDefine(&buf, "HAVE_ALIGNED_ALLOC", s.haveAlignedAlloc)
	writeBoolDefine(&buf, "HAVE_GET_ENTROPY", s.haveGetEntropy)
	writeBoolDefine(&buf, "HAVE_WCSDUP", s.haveWcsdup)
	writeBoolDefine(&buf, "CAN_AUTOSTART", s.enableAutostart && s.haveAtomicCloexec)
	writeBoolDefine(&buf, "CAN_SEND_UNIX_FDS", s.haveScmRights && s.haveAtomicCloexec)
	if !bytes.Equal(prev, buf.Bytes()) {
		f, err := os.Create("config.h")
		must(err)
		f.Write(buf.Bytes())
		f.Close()
	}
}

func (s *settings) writeCompile(w io.Writer, lib string, src string, objs []string) []string {
	fn := filepath.Base(src)
	ext := filepath.Ext(fn)
	base := fn[:len(fn)-len(ext)]
	platform := filepath.Ext(base)
	if platform == "" || s.platforms[platform[1:]] {
		out := filepath.Join("obj", lib, base+s.objExtension)
		fmt.Fprintf(w, "build %s: cc %s\n", out, src)
		return append(objs, out)
	} else {
		return objs
	}
}

func (s *settings) writeCompileDir(w io.Writer, dir string, name string) []string {
	objs := []string{}
	for _, c := range getFiles(dir, ".c") {
		objs = s.writeCompile(w, name, c, objs)
	}
	return objs
}

func (s *settings) writeLib(w io.Writer, lib string, objs []string) {
	out := filepath.Join("obj", lib+s.libExtension)
	fmt.Fprintf(w, "build %s: lib $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(w, " %s $\n", obj)
	}
	fmt.Fprintf(w, "\n")
}

func (s *settings) writeLibDir(w io.Writer, dir string, lib string) {
	objs := s.writeCompileDir(w, dir, lib)
	s.writeLib(w, lib, objs)
}

func (s *settings) writeExe(w io.Writer, exe string, objs []string, libs []string) {
	out := filepath.Join("bin", exe+s.exeExtension)
	fmt.Fprintf(w, "build %s: link $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(w, " %s $\n", obj)
	}
	for _, lib := range libs {
		pn := filepath.Join("obj", lib+s.libExtension)
		fmt.Fprintf(w, " %s $\n", pn)
	}
	fmt.Fprintf(w, "\n")
}

func (s *settings) writeExeDir(w io.Writer, dir string, exe string, libs []string) {
	objs := s.writeCompileDir(w, dir, exe)
	s.writeExe(w, exe, objs, libs)
}

func (s *settings) writeDefault(w io.Writer, exes []string) {
	fmt.Fprintf(w, "default $\n")
	for _, exe := range exes {
		pn := filepath.Join("bin", exe+s.exeExtension)
		fmt.Fprintf(w, " %s $\n", pn)
	}
	fmt.Fprintf(w, "\n")
}

func (s *settings) gccCCFlags(out string) []string {
	if s.enableDebug {
		return append([]string{
			"-g", "-Wall", "-Werror", "-I.",
			"-o", out, "-MD", "-MF", out + ".d",
		}, s.compileFlagsParts...)
	} else {
		return append([]string{
			"-O2", "-DNDEBUG", "-I.", "-o",
			out, "-MD", "-MF", out + ".d",
		}, s.compileFlagsParts...)
	}
}

func (s *settings) gccARFlags() string {
	return s.archiveFlags + " $out"
}

func (s *settings) msvcCFlags(out string) []string {
	if s.enableDebug {
		return append([]string{
			"/nologo", "/Z7", "/MTd", "/WX",
			"/W3", "/wd5045", "/Od", "/I.",
			"/showIncludes", "/Fo:" + out,
		}, s.compileFlagsParts...)
	} else {
		return append([]string{
			"/nologo", "/MT", "/W3", "/DNDEBUG",
			"/I.", "/showIncludes", "/Fo:" + out,
		}, s.compileFlagsParts...)
	}
}

func (s *settings) msvcLibFlags() string {
	return "/nologo /OUT:$out " + s.archiveFlags
}

func (s *settings) msvcLinkFlags() string {
	if s.enableDebug {
		return "/nologo /DEBUG /WX /OUT:$out " + s.linkFlags
	} else {
		return "/nologo /OUT:$out " + s.linkFlags
	}

}

func (s *settings) writeRules(w io.Writer) {
	var ldflags, libflags, deps string
	var cflags []string
	switch s.depsType {
	case "gcc":
		deps = " depfile = $out.d\n deps = gcc\n"
		cflags = append(s.gccCCFlags("$out"), "-c")
		ldflags = strings.Join(s.gccCCFlags("$out"), " ")
		libflags = s.gccARFlags()
	case "msvc":
		deps = " deps = msvc\n"
		cflags = append(s.msvcCFlags("$out"), "/c")
		ldflags = s.msvcLinkFlags()
		libflags = s.msvcLibFlags()
	}

	fmt.Fprintf(w, "# auto generated by configure.go\n")
	fmt.Fprintf(w, "rule cc\n description = CC $out\n%s command = %s %s $in\n\n",
		deps, s.compiler, strings.Join(cflags, " "))
	fmt.Fprintf(w, "rule link\n description = LINK $out\n command = %s %s $in\n\n",
		s.linker, ldflags)
	fmt.Fprintf(w, "rule lib\n description = LIB $out\n command = %s %s $in\n\n",
		s.archiver, libflags)

}

func main() {
	s := new(settings)
	goos := runtime.GOOS
	if override := os.Getenv("GOOS"); override != "" {
		goos = override
	}
	checkPosixFlags := false
	def := []string{"zbus", "tester"}
	s.platforms = make(map[string]bool)
	s.platforms[goos] = true
	switch goos {
	case "windows":
		checkPosixFlags = false
		s.compiler = "cl.exe"
		s.compileFlags = "/std:c11 /experimental:c11atomics"
		s.linker = "link.exe"
		s.linkFlags = ""
		s.archiver = "lib.exe"
		s.archiveFlags = ""
		s.haveWindowsSID = true
		s.haveAtomicCloexec = true
		s.depsType = "msvc"
		s.exeExtension = ".exe"
		s.libExtension = ".lib"
		s.objExtension = ".obj"
		def = append(def, "zbus-launch")

	case "linux":
		s.haveProcGroups = true
		fallthrough
	default:
		checkPosixFlags = true
		s.depsType = "gcc"
		s.compiler = "gcc"
		s.compileFlags = "-std=c11"
		s.linker = "gcc"
		s.linkFlags = ""
		s.archiver = "rm -f $out && ar rcs"
		s.archiveFlags = ""
		s.haveReadyFifo = true
		s.exeExtension = ""
		s.libExtension = ".a"
		s.objExtension = ".o"
		s.platforms["posix"] = true
		def = append(def, "gcc-ci-parser")
	}

	flag.StringVar(&s.compiler, "cc", s.compiler, "Compiler to use")
	flag.StringVar(&s.compileFlags, "cflags", s.compileFlags, "Compile flags to use")
	flag.StringVar(&s.archiver, "lib", s.archiver, "Archiver to use")
	flag.StringVar(&s.archiveFlags, "libflags", s.archiveFlags, "Archive flags to use")
	flag.StringVar(&s.linker, "link", s.linker, "Linker to use")
	flag.StringVar(&s.linkFlags, "linkflags", s.linkFlags, "Link flags to use")
	flag.StringVar(&s.depsType, "deps", s.depsType, "Ninja dependency type")
	flag.BoolVar(&s.enableDebug, "debug", s.enableDebug, "Enable debug compile")
	flag.BoolVar(&s.enableAutostart, "enable-autostart", s.enableAutostart, "Enable autostart")
	flag.Parse()

	s.compileFlagsParts = strings.Split(s.compileFlags, " ")

	var err error
	s.tmpdir, err = os.MkdirTemp("", "configure-go-*")
	must(err)
	defer os.RemoveAll(s.tmpdir)

	log.Printf("checking compiler")
	if err := s.compile("int main(void) {return 0;}"); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR - compiler %v %v doesn't work - %v\n", s.compiler, s.compileFlags, err)
		os.Exit(2)
	}

	if checkPosixFlags {
		s.haveAtomicCloexec = s.testCompile(`
			#define _GNU_SOURCE
			#include <sys/socket.h>
			#include <stddef.h>
			int main(void) {
				struct msghdr m;
				memset(&m, 0, sizeof(m));
				recvmsg(0, &m, MSG_CMSG_CLOEXEC);
				return accept4(0, NULL, NULL, SOCK_CLOEXEC | SOCK_NONBLOCK);
			}
		`)

		s.haveUnixGroups = s.testCompile(`
			#include <sys/types.h>
			#include <grp.h>
			int main(void) {
				struct group *g = getgrnam("user");
				return (int)g->gr_gid;
			}
		`)
		s.haveScmRights = s.testCompile(`
			#include <sys/types.h>
			#include <sys/socket.h>
			#include <sys/un.h>
			#include <unistd.h>
			#include <string.h>
			int main(void) {
				char buf[256];
				struct msghdr m;
				memset(&m, 0, sizeof(m));
				m.msg_control = buf;
				m.msg_controllen = sizeof(buf);
				struct cmsghdr *c = CMSG_FIRSTHDR(&m);
				c->cmsg_level = SOL_SOCKET;
				c->cmsg_type = SCM_RIGHTS;
				c->cmsg_len = CMSG_LEN(sizeof(int));
				int *pfd = (int*)CMSG_DATA(c);
				int fd = 0;
				memcpy(pfd, &fd, sizeof(int));
				return (int)sendmsg(0, &m, 0);
			}
		`)

		s.haveGetEntropy = s.testCompile(`
			#define _DEFAULT_SOURCE
			#include <unistd.h>
			int main(void) {
				char buf[16];
				return getentropy(buf, sizeof(buf));
			}
		`)
	}

	s.haveAlignedAlloc = s.testCompile(`
		#define _ISO_C11_SOURCE
		#include <stdlib.h>
		int main(void) {
			return aligned_alloc(16,16) != 0;
		}
	`)

	s.haveMemrchr = s.testCompile(`
		#define _GNU_SOURCE
		#include <string.h>
		int main(void) {
			return memrchr("foo", 'o', 3) != 0;
		}
	`)

	s.haveWcsdup = s.testCompile(`
		#include <wchar.h>
		int main(void) {
			wchar_t *t = wcsdup(L"foo");
			return t != NULL;
		}
	`)

	s.writeConfigHeader()

	f, err := os.Create("build.ninja")
	must(err)
	defer f.Close()
	s.writeRules(f)
	objs := s.writeCompile(f, "c-rbtree", "vendor/c-rbtree-3.1.0/src/c-rbtree.c", nil)
	s.writeLib(f, "c-rbtree", objs)
	s.writeLibDir(f, "dbus", "dbus")
	s.writeLibDir(f, "lib", "lib")
	s.writeExeDir(f, "zbus", "zbus", []string{"dbus", "lib", "c-rbtree"})
	s.writeExeDir(f, "tester", "tester", []string{"dbus", "lib"})
	s.writeExeDir(f, "gcc-ci-parser", "gcc-ci-parser", []string{"lib"})
	s.writeExeDir(f, "zbus-launch", "zbus-launch", []string{"lib"})
	s.writeDefault(f, def)
}
