package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

type settings struct {
	tmpdir string

	platforms map[string]bool

	exeExtension string
	libExtension string
	objExtension string

	compiler string
	cflags   []string
	linker   string
	ldflags  []string
	syslibs  []string
	archiver string
	libflags []string

	msvc bool

	disableAutostart bool
	debug            bool

	haveProcGroups    bool
	haveReadyFifo     bool
	haveAtomicCloexec bool
	haveUnixGroups    bool
	haveWindowsSID    bool
	haveMemrchr       bool
	haveAlignedAlloc  bool
	haveGetEntropy    bool
	haveWcsdup        bool
	haveStrchrnul     bool
	haveScmRights     bool
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func (s *settings) compile(str string) error {
	f, err := os.CreateTemp(s.tmpdir, "test*.c")
	fn := f.Name()
	must(err)
	f.WriteString(str)
	f.Close()

	var args []string
	if s.msvc {
		args = append(s.cflags,
			"/Fo:"+fn+".obj",
			"/Fe:"+fn+".exe",
		)
	} else {
		args = append(s.cflags,
			"-o", fn+".o",
		)
	}
	args = append(args, fn)
	log.Printf("CC %q %v %v", str, s.compiler, args)
	cmd := exec.Command(s.compiler, args...)
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	log.Printf("CC returned %v", err)
	return err
}

func (s *settings) testCompile(str string) bool {
	return s.compile(str) == nil
}

func getFiles(dir, ext string) []string {
	entries, err := os.ReadDir(dir)
	must(err)
	ret := []string{}
	for _, e := range entries {
		if !e.IsDir() && filepath.Ext(e.Name()) == ".c" {
			ret = append(ret, filepath.Join(dir, e.Name()))
		}
	}
	return ret
}

func writeBoolDefine(w io.Writer, name string, val bool) {
	if val {
		fmt.Fprintf(w, "#define %s\n", name)
	} else {
		fmt.Fprintf(w, "#undef %s\n", name)
	}
}

func (s *settings) writeConfigHeader() {
	prev, _ := os.ReadFile("config.h")

	buf := bytes.Buffer{}
	fmt.Fprintf(&buf, "#pragma once\n")
	fmt.Fprintf(&buf, "// auto generated by configure.go\n")
	writeBoolDefine(&buf, "HAVE_PROC_GROUPS", s.haveProcGroups)
	writeBoolDefine(&buf, "HAVE_READY_FIFO", s.haveReadyFifo)
	writeBoolDefine(&buf, "HAVE_ATOMIC_CLOEXEC", s.haveAtomicCloexec)
	writeBoolDefine(&buf, "HAVE_UNIX_GROUPS", s.haveUnixGroups)
	writeBoolDefine(&buf, "HAVE_WINDOWS_SID", s.haveWindowsSID)
	writeBoolDefine(&buf, "HAVE_MEMRCHR", s.haveMemrchr)
	writeBoolDefine(&buf, "HAVE_ALIGNED_ALLOC", s.haveAlignedAlloc)
	writeBoolDefine(&buf, "HAVE_GET_ENTROPY", s.haveGetEntropy)
	writeBoolDefine(&buf, "HAVE_WCSDUP", s.haveWcsdup)
	writeBoolDefine(&buf, "HAVE_STRCHRNUL", s.haveStrchrnul)
	writeBoolDefine(&buf, "CAN_AUTOSTART", !s.disableAutostart && s.haveAtomicCloexec)
	writeBoolDefine(&buf, "CAN_SEND_UNIX_FDS", s.haveScmRights && s.haveAtomicCloexec)
	writeBoolDefine(&buf, "NDEBUG", !s.debug)
	if s.msvc {
		writeBoolDefine(&buf, "_CRT_SECURE_NO_WARNINGS", true)
		writeBoolDefine(&buf, "_CRT_SECURE_NO_DEPRECATE", true)
	}
	if !bytes.Equal(prev, buf.Bytes()) {
		f, err := os.Create("config.h")
		must(err)
		f.Write(buf.Bytes())
		f.Close()
	}
}

func (s *settings) writeCompile(w io.Writer, lib string, src string, objs []string) []string {
	fn := filepath.Base(src)
	ext := filepath.Ext(fn)
	base := fn[:len(fn)-len(ext)]
	platform := filepath.Ext(base)
	if platform == "" || s.platforms[platform[1:]] {
		out := filepath.Join("obj", lib, base+s.objExtension)
		fmt.Fprintf(w, "build %s: cc %s\n", out, src)
		return append(objs, out)
	} else {
		return objs
	}
}

func (s *settings) writeCompileDir(w io.Writer, dir string, name string) []string {
	objs := []string{}
	for _, c := range getFiles(dir, ".c") {
		objs = s.writeCompile(w, name, c, objs)
	}
	return objs
}

func (s *settings) writeLib(w io.Writer, lib string, objs []string) string {
	out := filepath.Join("obj", lib+s.libExtension)
	fmt.Fprintf(w, "build %s: lib $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(w, " %s $\n", obj)
	}
	fmt.Fprintf(w, "\n")
	return out
}

func (s *settings) writeLibDir(w io.Writer, dir string, lib string) string {
	objs := s.writeCompileDir(w, dir, lib)
	return s.writeLib(w, lib, objs)
}

func (s *settings) writeExe(w io.Writer, exe string, objs, deps []string) string {
	out := filepath.Join("bin", exe+s.exeExtension)
	fmt.Fprintf(w, "build %s: exe $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(w, " %s $\n", obj)
	}
	for _, dep := range deps {
		fmt.Fprintf(w, " %s $\n", dep)
	}
	fmt.Fprintf(w, "\n")
	return out
}

func (s *settings) writeExeDir(w io.Writer, dir string, exe string, deps []string) string {
	objs := s.writeCompileDir(w, dir, exe)
	return s.writeExe(w, exe, objs, deps)
}

func (s *settings) writeDefault(w io.Writer, exes []string) {
	fmt.Fprintf(w, "default $\n")
	for _, exe := range exes {
		pn := filepath.Join("bin", exe+s.exeExtension)
		fmt.Fprintf(w, " %s $\n", pn)
	}
	fmt.Fprintf(w, "\n")
}

func (s *settings) writeRules(w io.Writer) {
	cflags := s.cflags
	ldflags := s.ldflags
	libflags := s.libflags
	syslibs := s.syslibs
	deps := ""
	if s.msvc {
		deps = " deps = msvc\n"
		cflags = append(cflags, "/c", "/Fo:$out")
		ldflags = append(ldflags, "/OUT:$out")
		libflags = append(libflags, "/OUT:$out")
	} else {
		deps = " depfile = $out.d\n deps = gcc\n"
		cflags = append(cflags, "-c", "-o", "$out", "-MD", "-MF", "$out.d")
		ldflags = append(ldflags, "-o", "$out")
		libflags = append(libflags, "$out")
	}

	fmt.Fprintf(w, "# auto generated by configure.go\n")
	fmt.Fprintf(w, "rule cc\n description = CC $out\n%s command = %s %s $in\n\n",
		deps, s.compiler, strings.Join(cflags, " "))
	fmt.Fprintf(w, "rule exe\n description = EXE $out\n command = %s %s $in %s\n\n",
		s.linker, strings.Join(ldflags, " "), strings.Join(syslibs, " "))
	fmt.Fprintf(w, "rule lib\n description = LIB $out\n command = %s %s $in\n\n",
		s.archiver, strings.Join(libflags, " "))

}

func (s *settings) addSystemLib(lib string) {
	if s.msvc {
		s.syslibs = append(s.syslibs, lib+".lib")
	} else {
		s.syslibs = append(s.syslibs, "-l"+lib)
	}
}

func split(flags string) []string {
	v := strings.Split(flags, " ")
	if len(v) == 1 && len(v[0]) == 0 {
		return nil
	}
	return v
}

func main() {
	msvc := false
	target := ""
	platform := runtime.GOOS
	cflags := ""
	s := new(settings)
	flag.BoolVar(&msvc, "msvc", msvc, "Enable msvc compiler mode")
	flag.StringVar(&target, "target", target, "GCC style binary prefix to use")
	flag.StringVar(&platform, "os", platform, "OS to target")
	flag.BoolVar(&s.disableAutostart, "no-autostart", s.disableAutostart, "Disable auto starting services")
	flag.BoolVar(&s.debug, "debug", s.debug, "Enable debug build")
	flag.StringVar(&cflags, "cflags", cflags, "Extra compile flags")
	flag.Parse()

	if msvc {
		s.msvc = true
		s.compiler = "cl.exe"
		s.cflags = append(
			split(cflags),
			"/FI", "config.h",
			"/nologo",
			"/showIncludes",
			"/wd5045",
			"/I.",
			"/std:c11",
			"/experimental:c11atomics",
		)
		s.linker = "link.exe"
		s.ldflags = []string{
			"/nologo",
		}
		s.archiver = "lib.exe"
		s.libflags = []string{
			"/nologo",
		}
		if s.debug {
			s.cflags = append(s.cflags,
				"/MTd",
				"/WX",
				"/W3",
				"/Od",
				"/Z7",
			)
			s.ldflags = append(s.ldflags,
				"/DEBUG",
				"/WX",
			)
		} else {
			s.cflags = append(s.cflags,
				"/MT",
			)
		}
	} else {
		if target != "" && !strings.HasSuffix(target, "-") {
			target += "-"
		}
		s.msvc = false
		s.compiler = target + "cc"
		s.cflags = append(
			split(cflags),
			"-include", "config.h",
			"-I.",
		)
		s.linker = target + "cc"
		s.ldflags = split(cflags)
		s.archiver = target + "ar"
		s.libflags = []string{
			"rcs",
		}
		if s.debug {
			s.cflags = append(s.cflags,
				"-g",
				"-Wall",
				"-Werror",
			)
			s.ldflags = append(s.ldflags,
				"-g",
				"-Wall",
				"-Werror",
			)
		} else {
			s.cflags = append(s.cflags,
				"-O2",
			)
			s.ldflags = append(s.ldflags,
				"-s",
			)
		}
	}

	def := []string{"zbus-daemon", "test-client", "test-server"}
	s.platforms = make(map[string]bool)
	s.platforms[platform] = true
	switch platform {
	case "windows":
		s.haveWindowsSID = true
		s.haveAtomicCloexec = true
		s.exeExtension = ".exe"
		s.libExtension = ".lib"
		s.objExtension = ".obj"
		def = append(def, "zbus-launch")
		s.addSystemLib("advapi32")
		s.addSystemLib("ws2_32")

	case "linux":
		s.haveProcGroups = true
		fallthrough
	default:
		s.haveReadyFifo = true
		s.exeExtension = ""
		s.libExtension = ".a"
		s.objExtension = ".o"
		s.platforms["posix"] = true
		def = append(def, "gcc-ci-parser")
	}

	var err error
	s.tmpdir, err = os.MkdirTemp("", "configure-go-*")
	must(err)
	defer os.RemoveAll(s.tmpdir)

	log.Printf("checking compiler")
	if err := s.compile("int main(void) {return 0;}"); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR - compiler %v %v doesn't work - %v\n", s.compiler, s.cflags, err)
		os.Exit(2)
	}

	if s.platforms["posix"] {
		s.haveAtomicCloexec = s.testCompile(`
			#define _GNU_SOURCE
			#include <sys/socket.h>
			#include <stddef.h>
			#include <string.h>
			int main(void) {
				struct msghdr m;
				memset(&m, 0, sizeof(m));
				recvmsg(0, &m, MSG_CMSG_CLOEXEC);
				return accept4(0, NULL, NULL, SOCK_CLOEXEC | SOCK_NONBLOCK);
			}
		`)

		s.haveUnixGroups = s.testCompile(`
			#include <sys/types.h>
			#include <grp.h>
			int main(void) {
				struct group *g = getgrnam("user");
				return (int)g->gr_gid;
			}
		`)
		s.haveScmRights = s.testCompile(`
			#include <sys/types.h>
			#include <sys/socket.h>
			#include <sys/un.h>
			#include <unistd.h>
			#include <string.h>
			int main(void) {
				char buf[256];
				struct msghdr m;
				memset(&m, 0, sizeof(m));
				m.msg_control = buf;
				m.msg_controllen = sizeof(buf);
				struct cmsghdr *c = CMSG_FIRSTHDR(&m);
				c->cmsg_level = SOL_SOCKET;
				c->cmsg_type = SCM_RIGHTS;
				c->cmsg_len = CMSG_LEN(sizeof(int));
				int *pfd = (int*)CMSG_DATA(c);
				int fd = 0;
				memcpy(pfd, &fd, sizeof(int));
				return (int)sendmsg(0, &m, 0);
			}
		`)

		s.haveGetEntropy = s.testCompile(`
			#define _DEFAULT_SOURCE
			#include <unistd.h>
			int main(void) {
				char buf[16];
				return getentropy(buf, sizeof(buf));
			}
		`)
	}

	s.haveAlignedAlloc = s.testCompile(`
		#define _ISO_C11_SOURCE
		#include <stdlib.h>
		int main(void) {
			return aligned_alloc(16,16) != 0;
		}
	`)

	s.haveMemrchr = s.testCompile(`
		#define _GNU_SOURCE
		#include <string.h>
		int main(void) {
			return memrchr("foo", 'o', 3) != 0;
		}
	`)

	s.haveWcsdup = s.testCompile(`
		#define _POSIX_C_SOURCE 200809L
		#include <wchar.h>
		int main(void) {
			wchar_t *t = wcsdup(L"foo");
			return t != NULL;
		}
	`)

	s.haveStrchrnul = s.testCompile(`
		#define _GNU_SOURCE
		#include <string.h>
		int main(int argc, char **argv) {
			char *end = strchrnul(argv[0], ',');
			return *end != 0;
		}
	`)

	s.writeConfigHeader()

	f, err := os.Create("build.ninja")
	must(err)
	defer f.Close()
	s.writeRules(f)
	objs := s.writeCompile(f, "c-rbtree", "vendor/c-rbtree-3.1.0/src/c-rbtree.c", nil)
	rbtree := s.writeLib(f, "c-rbtree", objs)
	zbus := s.writeLibDir(f, "zbus", "libzbus")
	common := s.writeLibDir(f, "lib", "libcommon")
	client := s.writeLibDir(f, "client", "libclient")
	s.writeExeDir(f, "zbus-daemon", "zbus-daemon", []string{common, rbtree, zbus})
	s.writeExeDir(f, "test-client", "test-client", []string{client, common, zbus})
	s.writeExeDir(f, "test-server", "test-server", []string{client, common, zbus})
	s.writeExeDir(f, "gcc-ci-parser", "gcc-ci-parser", []string{common})
	s.writeExeDir(f, "zbus-launch", "zbus-launch", []string{common})
	s.writeDefault(f, def)
}
