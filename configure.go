package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

type settings struct {
	tmpdir string

	platforms map[string]bool

	exeExtension string
	libExtension string
	objExtension string

	compiler          string
	compileFlags      string
	compileFlagsParts []string
	linker            string
	linkFlags         string
	archiver          string
	archiveFlags      string
	depsType          string

	enableAutostart bool
	enableDebug     bool

	haveProcGroups   bool
	haveReadyFifo    bool
	haveListenFD     bool
	haveAccept4      bool
	haveUnixGroups   bool
	haveWindowsSID   bool
	haveMemrchr      bool
	haveAlignedAlloc bool
	haveGetEntropy   bool
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func (s *settings) compile(str string) error {
	f, err := os.CreateTemp(s.tmpdir, "test*.c")
	fn := f.Name()
	must(err)
	f.WriteString(str)
	f.Close()

	var args []string
	switch s.depsType {
	case "gcc":
		args = s.gccCCFlags(fn + ".o")
	case "msvc":
		args = append(s.msvcCFlags(fn+".obj"), "/Fe:"+fn+".exe")
	}
	args = append(args, fn)
	log.Printf("CC %q %v %v", str, s.compiler, args)
	cmd := exec.Command(s.compiler, args...)
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	log.Printf("CC returned %v", err)
	return err
}

func (s *settings) testCompile(str string) bool {
	return s.compile(str) == nil
}

func getFiles(dir, ext string) []string {
	entries, err := os.ReadDir(dir)
	must(err)
	ret := []string{}
	for _, e := range entries {
		if !e.IsDir() && filepath.Ext(e.Name()) == ".c" {
			ret = append(ret, filepath.Join(dir, e.Name()))
		}
	}
	return ret
}

func writeBoolDefine(f *os.File, name string, val bool) {
	v := 0
	if val {
		v = 1
	}
	fmt.Fprintf(f, "#define %s %d\n", name, v)
}

func (s *settings) writeConfigHeader() {
	f, err := os.Create("config.h")
	must(err)
	defer f.Close()

	fmt.Fprintf(f, "#pragma once\n")
	fmt.Fprintf(f, "// auto generated by configure.go\n")
	writeBoolDefine(f, "HAVE_PROC_GROUPS", s.haveProcGroups)
	writeBoolDefine(f, "HAVE_READY_FIFO", s.haveReadyFifo)
	writeBoolDefine(f, "HAVE_LISTENFD", s.haveListenFD)
	writeBoolDefine(f, "HAVE_ACCEPT4", s.haveAccept4)
	writeBoolDefine(f, "HAVE_UNIX_GROUPS", s.haveUnixGroups)
	writeBoolDefine(f, "HAVE_WINDOWS_SID", s.haveWindowsSID)
	writeBoolDefine(f, "HAVE_MEMRCHR", s.haveMemrchr)
	writeBoolDefine(f, "HAVE_ALIGNED_ALLOC", s.haveAlignedAlloc)
	writeBoolDefine(f, "HAVE_GET_ENTROPY", s.haveGetEntropy)
	writeBoolDefine(f, "ENABLE_AUTOSTART", s.enableAutostart)
}

func (s *settings) writeCompile(f *os.File, lib string, src string, objs []string) []string {
	fn := filepath.Base(src)
	ext := filepath.Ext(fn)
	base := fn[:len(fn)-len(ext)]
	platform := filepath.Ext(base)
	if platform == "" || s.platforms[platform[1:]] {
		out := filepath.Join("obj", lib, base+s.objExtension)
		fmt.Fprintf(f, "build %s: cc %s\n", out, src)
		return append(objs, out)
	} else {
		return objs
	}
}

func (s *settings) writeCompileDir(f *os.File, dir string, name string) []string {
	objs := []string{}
	for _, c := range getFiles(dir, ".c") {
		objs = s.writeCompile(f, name, c, objs)
	}
	return objs
}

func (s *settings) writeLib(f *os.File, lib string, objs []string) {
	out := filepath.Join("obj", lib+s.libExtension)
	fmt.Fprintf(f, "build %s: lib $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(f, " %s $\n", obj)
	}
	fmt.Fprintf(f, "\n")
}

func (s *settings) writeLibDir(f *os.File, dir string, lib string) {
	objs := s.writeCompileDir(f, dir, lib)
	s.writeLib(f, lib, objs)
}

func (s *settings) writeExe(f *os.File, exe string, objs []string, libs []string) {
	out := filepath.Join("bin", exe+s.exeExtension)
	fmt.Fprintf(f, "build %s: link $\n", out)
	for _, obj := range objs {
		fmt.Fprintf(f, " %s $\n", obj)
	}
	for _, lib := range libs {
		pn := filepath.Join("obj", lib+s.libExtension)
		fmt.Fprintf(f, " %s $\n", pn)
	}
	fmt.Fprintf(f, "\n")
}

func (s *settings) writeExeDir(f *os.File, dir string, exe string, libs []string) {
	objs := s.writeCompileDir(f, dir, exe)
	s.writeExe(f, exe, objs, libs)
}

func (s *settings) writeDefault(f *os.File, exes []string) {
	fmt.Fprintf(f, "default $\n")
	for _, exe := range exes {
		pn := filepath.Join("bin", exe+s.exeExtension)
		fmt.Fprintf(f, " %s $\n", pn)
	}
	fmt.Fprintf(f, "\n")
}

func (s *settings) gccCCFlags(out string) []string {
	if s.enableDebug {
		return append([]string{
			"-g", "-Wall", "-Werror", "-I.",
			"-o", out, "-MD", "-MF", out + ".d",
		}, s.compileFlagsParts...)
	} else {
		return append([]string{
			"-O2", "-DNDEBUG", "-I.", "-o",
			out, "-MD", "-MF", out + ".d",
		}, s.compileFlagsParts...)
	}
}

func (s *settings) gccARFlags() string {
	return s.archiveFlags + " $out"
}

func (s *settings) msvcCFlags(out string) []string {
	if s.enableDebug {
		return append([]string{
			"/nologo", "/Z7", "/MTd", "/WX",
			"/W3", "/wd5045", "/Od", "/I.",
			"/showIncludes", "/Fo:" + out,
		}, s.compileFlagsParts...)
	} else {
		return append([]string{
			"/nologo", "/MT", "/W3", "/DNDEBUG",
			"/I.", "/showIncludes", "/Fo:" + out,
		}, s.compileFlagsParts...)
	}
}

func (s *settings) msvcLibFlags() string {
	return "/nologo /OUT:$out " + s.archiveFlags
}

func (s *settings) msvcLinkFlags() string {
	if s.enableDebug {
		return "/nologo /DEBUG /WX /OUT:$out " + s.linkFlags
	} else {
		return "/nologo /OUT:$out " + s.linkFlags
	}

}

func (s *settings) writeRules(f *os.File) {
	var ldflags, libflags, deps string
	var cflags []string
	switch s.depsType {
	case "gcc":
		deps = " depfile = $out.d\n deps = gcc\n"
		cflags = append(s.gccCCFlags("$out"), "-c")
		ldflags = strings.Join(s.gccCCFlags("$out"), " ")
		libflags = s.gccARFlags()
	case "msvc":
		deps = " deps = msvc\n"
		cflags = append(s.msvcCFlags("$out"), "/c")
		ldflags = s.msvcLinkFlags()
		libflags = s.msvcLibFlags()
	}

	fmt.Fprintf(f, "# auto generated by configure.go\n")
	fmt.Fprintf(f, "rule cc\n description = CC $out\n%s command = %s %s $in\n\n",
		deps, s.compiler, strings.Join(cflags, " "))
	fmt.Fprintf(f, "rule link\n description = LINK $out\n command = %s %s $in\n\n",
		s.linker, ldflags)
	fmt.Fprintf(f, "rule lib\n description = LIB $out\n command = %s %s $in\n\n",
		s.archiver, libflags)

}

func main() {
	s := new(settings)
	goos := runtime.GOOS
	if override := os.Getenv("GOOS"); override != "" {
		goos = override
	}
	s.platforms = make(map[string]bool)
	s.platforms[goos] = true
	switch goos {
	case "windows":
		s.compiler = "cl.exe"
		s.compileFlags = "/std:c11 /experimental:c11atomics"
		s.linker = "link.exe"
		s.linkFlags = ""
		s.archiver = "lib.exe"
		s.archiveFlags = ""
		s.haveWindowsSID = true
		s.depsType = "msvc"
		s.exeExtension = ".exe"
		s.libExtension = ".lib"
		s.objExtension = ".obj"

	case "linux":
		s.haveProcGroups = true
		fallthrough
	default:
		s.depsType = "gcc"
		s.compiler = "gcc"
		s.compileFlags = "-std=c11"
		s.linker = "gcc"
		s.linkFlags = ""
		s.archiver = "rm -f $out && ar rcs"
		s.archiveFlags = ""
		s.haveListenFD = true
		s.haveReadyFifo = true
		s.exeExtension = ""
		s.libExtension = ".a"
		s.objExtension = ".o"
		s.platforms["posix"] = true
	}

	flag.StringVar(&s.compiler, "cc", s.compiler, "Compiler to use")
	flag.StringVar(&s.compileFlags, "cflags", s.compileFlags, "Compile flags to use")
	flag.StringVar(&s.archiver, "lib", s.archiver, "Archiver to use")
	flag.StringVar(&s.archiveFlags, "libflags", s.archiveFlags, "Archive flags to use")
	flag.StringVar(&s.linker, "link", s.linker, "Linker to use")
	flag.StringVar(&s.linkFlags, "linkflags", s.linkFlags, "Link flags to use")
	flag.StringVar(&s.depsType, "deps", s.depsType, "Ninja dependency type")
	flag.BoolVar(&s.enableDebug, "debug", s.enableDebug, "Enable debug compile")
	flag.BoolVar(&s.enableAutostart, "enable-autostart", s.enableAutostart, "Enable autostart")
	flag.Parse()

	s.compileFlagsParts = strings.Split(s.compileFlags, " ")

	var err error
	s.tmpdir, err = os.MkdirTemp("", "configure-go-*")
	must(err)
	defer os.RemoveAll(s.tmpdir)

	log.Printf("checking compiler")
	if err := s.compile("int main(void) {return 0;}"); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR - compiler %v %v doesn't work - %v\n", s.compiler, s.compileFlags, err)
		os.Exit(2)
	}

	s.haveAccept4 = s.testCompile(`
		#define _GNU_SOURCE
		#include <sys/socket.h>
		#include <stddef.h>
		int main(void) {
			return accept4(0, NULL, NULL, SOCK_CLOEXEC | SOCK_NONBLOCK);
		}
	`)

	s.haveAlignedAlloc = s.testCompile(`
		#define _ISO_C11_SOURCE
		#include <stdlib.h>
		int main(void) {
			return aligned_alloc(16,16) != 0;
		}
	`)

	s.haveMemrchr = s.testCompile(`
		#define _GNU_SOURCE
		#include <string.h>
		int main(void) {
			return memrchr("foo", 'o', 3) != 0;
		}
	`)

	s.haveGetEntropy = s.testCompile(`
		#define _DEFAULT_SOURCE
		#include <unistd.h>
		int main(void) {
			char buf[16];
			return getentropy(buf, sizeof(buf));
		}
	`)

	s.haveUnixGroups = s.testCompile(`
		#include <sys/types.h>
		#include <grp.h>
		int main(void) {
			struct group *g = getgrnam("user");
			return (int)g->gr_gid;
		}
	`)

	s.writeConfigHeader()

	f, err := os.Create("build.ninja")
	must(err)
	defer f.Close()
	s.writeRules(f)
	objs := s.writeCompile(f, "c-rbtree", "vendor/c-rbtree-3.1.0/src/c-rbtree.c", nil)
	s.writeLib(f, "c-rbtree", objs)
	s.writeLibDir(f, "dbus", "dbus")
	s.writeLibDir(f, "lib", "lib")
	s.writeExeDir(f, "zbus", "zbus", []string{"dbus", "lib", "c-rbtree"})
	s.writeExeDir(f, "tester", "tester", []string{"dbus", "lib"})
	s.writeExeDir(f, "gcc-ci-parser", "gcc-ci-parser", []string{"lib"})
	s.writeDefault(f, []string{
		"zbus",
		"tester",
	})
}
